


=head1 NAME

agp2tpf.pl - quick hack to convert AGP to TPF.

=head1 SYNOPSYS

agp2tpf.pl -f local2acc_id_mapping agpdir/

=head2 TPF SPECS

Column definitions for sequence lines: 

Column 1: accession number. This must be a valid accession assigned by the International DNA Sequence Database (GenBank/EMBL/DDBJ). No version number should be used. It is assumed that the current version of the accessioniswhatisintended. OPTIONAL,useâ?âifunknown. 

Column 2: clone name. If the sequence is defined by a clone, then the clone name should be specified here. Ideally, standard Clone Registry nomenclature will be used. If a sequence is derived from more than one clone, the clone name can be given as âMULTIPLEâ. OPTIONAL, use â?â if unknown. 

Column 3: local contig identifier. Name given to the scaffold/contig generated by assembling the listed sequences. REQUIRED.
ï·	NOTE: Use of â.â (the âdotâ character) is not allowed in contig identifiers.
ï·	NOTE: A local contig identifier may only be used once per assembly.

Column 4: contained status. This line is only used to specify clones that are known to be contained within another clone on the TPF. The only values allowed are âCONTAINEDâ and âCONTAINED_TURNOUTâ. REQUIRED for contained clones, otherwise OPTIONAL.

Column 5: accession number. This must be a valid accession assigned by the INSDC. No version number should be used. It is assumed that the current version of the accession is what is intended. The accession provided in this column must be in column 1 on another line of the same TPF and must also belong to the same local contig (column 3) as the contained clone. See below for requirements. REQUIRED if COLUMN 4 is CONTAINED or CONTAINED_TURNOUT, otherwise not valid.

Column 6: clone name. The clone name used in this column should correspond to the accession listed in column 5, if the sequence is derived from a clone. Ideally, standard Clone Registry nomenclature will be used. See below for requirements. REQUIRED IF COLUMN 4 is CONTAINED or CONTAINED_TURNOUT, otherwise not valid. NOTE1: Columns 5 and 6- these are similar to columns 1 and 2 in that at least one, but not both, requires a value. However, if both are known, please supply both values. NOTE2: If column 4 is not populated in a sequence line, do not populate columns 4, 5 or 6. If column 4 is populated, then provide values or â?â for columns 5 and 6.

TPF GAP TYPES:
TYPE-1: [Deprecated]- was a place-holder for a picked clone. 
TYPE-2: clone gap 
TYPE-3: contig gap- unable to close using available technology 
Biological Gap: If there is a biological gap such as a centromere, etc. then use the name rather than type-4. 
This is a controlled vocabulary:
    o CENTROMERE 
    o TELOMERE 
    o HETEROCHROMATIN 
    o SHORT-ARM

Description of AGP gap types:
- (A) active_finishing
- (D) draft
- (F) finished
- (G) wgs_finishing
- (N) known_gap
- (O) other
- (P) predraft
- (U) unknown_gap
- (W) wgs_contig

=cut

use Modern::Perl;

use Getopt::Std;

use CXGN::BioTools::AGP qw | agp_parse |;

our %args;

getopts('l:c:', \%args); # -l <local mapping file> -c contig def file

my $dir = shift;

my %ids;

if (!$args{l}) { 
    print "option -l required. provide local mapping file.\n";
    exit(1);
}

print STDERR "Read the mapping file $args{l}...\n";
open (my $F, "<", $args{l}) || die "Can't open file $args{l}";

while (<$F>) { 
    chomp;
    my ($local_id, $acc) = split /\t/;
    $acc =~ s/(.*?)\.\d+/$1/; #remove version number
    #print STDERR "READ: $local AND $acc\n";
    $ids{$acc} = $local_id;
}
close($F);

my %ct;

if ($args{c}) { 
    open ($F, "<", $args{c}) || die "Can't open file $args{c}\n";
    while (<$F>) { 
	chomp;
	my ($sc, $ct) = split /\t/;
	# remove version number
	##print STDERR "$ct contained in $sc\n";
	$ct{$ct} = $sc;
    }   
}
    
my $cultivar = "Heinz 1706";
my $assembly_version = "2.4";

my $agp;

my %gap_types = ( fragment => "TYPE-2",
		  centromere => "CENTROMERE",
		  telomere => "TELOMERE",
		  heterochromatin => "HETEROCHROMATIN",
		  "short-arm" => "SHORT-ARM",
		  repeat => "TYPE-2",
		  contig => "TYPE-3",
		  clone => "TYPE-2",
    );


foreach my $file (glob $dir."/*.agp") { 

    print STDERR "Processing file $file.\n";
    $agp = agp_parse($file);
    
    my $chr_nr = $file;
    $chr_nr =~ s/.*(\d+).*/$1/;


    print STDERR "Processing chromosome $chr_nr\n";
    
    open (my $F, ">", $file.".tpf") || die "Can't open tpf file $file.pdf";


    # print header for tomato

	print $F <<HEADER;
##ORGANISM: Solanum lycopersicum 
##ASSEMBLY NAME: Reference 
##CHROMOSOME: $chr_nr
##STRAIN/HAPLOTYPE/CULTIVAR: $cultivar
##TYPE: Complete Chromosome
##Version: $assembly_version
##Comment:  
##SUBMITTER: International Tomato Genome Project (http://solgenomics.net/) 
##CREATE DATE: March 21, 2011
##UPDATE DATE: March 21, 2011

## --- Beginning of TPF Data ---
HEADER


    foreach my $line (@$agp) { 
	
	if ($line =~ /^\#/ || !$line) { next; } # skip comment lines
	    
	my $gap_size;
	my $method = "";
	my $direction;
	# remove the version number in the identifier
	if (exists($line->{ident})) { $line->{ident} =~ s/(.*?)\.\d+/$1/; }

	if (exists($line->{type}) && defined($line->{type})) { 
	    if ($line->{type} eq "W") { 
		my $local_id;
		
		#orientation:
		if(exists($line->{orient})){

		   # print STDERR "Orientation calculating... ";
		    if($line->{orient} eq '-'){
			$direction = "MINUS";
		    }
		    elsif($line->{orient} eq '+'){
			$direction = "PLUS";
		    }
		}


		if(exists($line->{ident}) && exists($ids{$line->{ident}})) { 
		    $local_id = $ids{$line->{ident}};
		    
		    #provide the scaffold if possible
		    if (exists($ct{$local_id})) { 
			$local_id = $ct{$local_id};
		    }
		    
		}
		else {
		    $local_id = "";
		}

		# a comp line, with component name, ? and the local contig id
		print $F join ("\t", (
				   $line->{ident},
				   "?",
				   $local_id,
				   $direction || '',
			       )
		    )."\n";
	    }
	}
	
	# deal with the gap lines
#	print STDERR "Linkage = $line->{linkage}\n";
	my $gap_type;
	#if (exists($line->{type}) && $line->{type} eq "U") { 
	    #if ($line->{gap_type} eq 'fragment' || $line->{gap_type} eq 'clone') { 


	#}
	if (exists($line->{type}) && $line->{type} eq "U") { 
	    $gap_size = '';
	    $method = "";
	}
	elsif (exists($line->{type}) && $line->{type} eq "N") { 	    
	    $gap_size = $line->{length};#$line->{oend} - $line->{ostart};
	    $gap_type = $gap_types{$line->{gap_type}};

	    $method = "PAIRED ENDS";
	    
	}
	else { 
	    $gap_size = '';
	}

	if (exists($line->{linkage}) && $line->{linkage} eq 'yes') { 
	    $gap_type='TYPE-2';
	}
	if (exists($line->{linkage}) && $line->{linkage} eq 'no') { 
	    $gap_type='TYPE-3';
	    $method = '';
	}

	    

	if (exists($line->{gap_type}) && exists($gap_types{$line->{gap_type}})) { 


	   
	    if (!defined($gap_size)) { $gap_size = ''; }
	    print $F join ("\t", (
			       "GAP",
			       $gap_type,
			       $gap_size,
			       $method || '',
			       '',
			       
			
		    )
	    )."\n";

	}
	else {
	   # print STDERR "Don't know gap type '$line->{gap_type}'\n";
	   # next();
	}
	
	
	
	   	
    }
    print $F "### --- End of TPF data ---\n";

    close($F);
}


